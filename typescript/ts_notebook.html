<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <link rel="stylesheet" href="style/style.css">
</head>
<body>

<h1>Yükleme</h1>
<div class="explain">
    <p>"npm install --global typescript" komutu ile yükleniyor.</p>
    <p>"tsc -v" ile versiyon kontrolü. npm init -y ile iligli dizinde package.json oluşturuluyor.</p>
    <p>"npx tsc whatevernameis.ts" komutu ile ts dosyasını js dosyasına çeviriyoruz.</p>
</div>


<hr>

<h1>Hello World</h1>

<div class="explain">
    <p>TS dünyasına ilk kodum (buraya açıklamalar gelicek)</p>
</div>
)

<pre><code>
function selamDunya() {
  console.log("Merhaba Dünya!");
}
</code>
</pre>
<output>
    Merhaba Dünya
</output>
<hr>
<h1>5 Temel Tip</h1>
<div class="explain">
    <p> boolean, number, string, Bigint(2^53 - 1 sayısından büyük), Symbol</p>
</div>
<pre>
    <code>
        //Boolean
        let isactive: boolean = false;
        let hasError = true;  //Python gibi kendisi de çıkarım yapabiliyor.

        //number
        let decimal: number = 25;
        let hex: number = 0xf00d;
        let binary: number = 0b1010;
        let octal: number = 0o744;
        let float: number = 3.14;

        //String
        let name: string = "Yusuf Can"
        let surname: string = "İbişoğlu"

let sentence: string = "Hello my name is " + name + " " + surname + " and I'm " + decimal + " Years old.";

console.log(sentence)
    </code>
</pre>

<output>
    Hello my name is Yusuf Can İbişoğlu and I'm 25 Years old.
</output>

<div class="explain">
<p>Symbol unique tanımlayıcılar oluşturur. Unique özellik key ve constant oluşturmak için kullanışlıdır.</p>
</div>
<pre><code>
    const uniqueKey: symbol = Symbol('description');
const obj = {
    [uniqueKey]: 'This is a unique property'
};
console.log(obj[uniqueKey]); // "This is a unique property"
</code></pre>
<output>
    This is a unique property
</output>

<hr>
<h1>Inference - Çıkarım</h1>
<div class="explain"><p>//return tipini de belirleyebiliyoruz. Belirlemessek çıkarım (inferrence) yapıyor.</p></div>
<pre>
    <code>
        function ornek(name: string): string {
    return `Hello, ${name}!`;}
    </code>
</pre>

<pre><code>const user = {
    name: 'yusuf',
    surname: "ibisoglu",
    isadmin: false,
    age: 25
}

    console.log(user.name);
</code></pre>

<output>
    yusuf
    undefined
</output>
<hr>
<div class="explain"><p>/*
    TypeScript inference özelliği oldukça güçlü. Ancak tipi tanımlayamadığı durumlar olabiliyor.
    mesela intellisense aşşağıda data değişkenini any olarak atadı. yazzdırdığımda ise object
    </p></div>

<pre><code>
    const data = JSON.parse('{"name":"yusuf","surname":"ibisoglu","isadmin":true}');
    console.log(typeof data);
</code></pre>

<output>
    object
</output>
<h1>any</h1>
<div class="explain"><p>any js kodumuzu ts'ye migrate(taşırken) ederken kullanabiliriz.</p>
<p>dinamik content ile çalışırken, tip unkown ise kullanılabilir</p>
</div>
<pre><code>
    let v: any = true;
v = "string"; // no error as it can be "any" type
Math.round(v); // no error as it can be "any" type
console.log(v); // "string"
    //genelde any error dönmez
</code></pre>

<hr>
<h1>Unknown</h1>
<div class="explain">
    <p>unknown any'nin güvenli versiyonu, property'leri çapıramassın</p>
    <p>kullanmadan önce kontrol etmemiz gerekiyor (assert) çağıramayız ve construct edemeyiz.</p>
</div>
<pre><code>
    let w: unknown = 1;

w = "string";

w = {
    runANonExistentMethod: () => {
        console.log("I think");
    }
} as { runANonExistentMethod: () => void }

    console.log(w)
    if (typeof w === 'object' && w !== null) {
    (w as { runANonExistentMethod: Function }).runANonExistentMethod();
}
</code></pre>

<output>
    object
    { runANonExistentMethod: [Function: runANonExistentMethod] }
    I think
</output>


<hr>
<h1>Unkown ne zaman kullanılır.</h1>
<div class="explain"><p>// Dışardan veri aldığımızda (API vs) veri tiplerinden emin olmamız gerektiğinde.
</p>
<p>// java scriptten Type Scripte güvenli bir geçiş yaptığımızda (kodları js den ts e çevirirken.)
</p></div>
<pre><code>
    // Unkown ne zaman kullanılır
    function processValue(value: unknown) {
    if (typeof value === 'string') {
    // value is now treated as string
    console.log(value.toUpperCase());
    } else if (Array.isArray(value)) {
    // value is now treated as any[]
    console.log(value.length);
    }
    }
    let absc: number[] = [2, 3];
    processValue(absc)
</code></pre>

<output>
    2
</output>
<hr>
<h1>Never type</h1>
<div class="explain"><p>// Hiç bir zaman meydana gelmeyecek / gelmemesi gereken değerleri temsil eder.
</p>
<p>Basic never type (throws error when assigned)
</p></div>
<pre>
    <code> //never return eden fonksyion
        function throwError(message: string): never {
    throw new Error(message);
}
        --------
        type Shape = Circle | Square | Triangle;

function getArea(shape: Shape): number {
    switch (shape.kind) {
        case 'circle':
            return Math.PI * shape.radius ** 2;
        case 'square':
            return shape.sideLength ** 2;
        default:
            // TypeScript knows this should never happen
            const _exhaustiveCheck: never = shape;
            return _exhaustiveCheck;
    }
}
        //Basic never type (throws error when assigned)
        let x: never = true; // Error: Type 'boolean' is not assignable to type 'never'.
    </code>
</pre>
<hr>
<h1>Type: undefined & null</h1>
<div class="explain"><p>Typescriptte undefined ve null birer tiptir, string veya number gibi.</p>
<p>bu tipler varsayılan olarak, herhangi bir tipe dönüştürülebilir.</p></div>
<pre><code>
    let y: undefined = undefined;
    let z: null = null;
    // Opsiyonel parametre ve property özellikleri  :
    // Optional parameter (implicitly `string | undefined`)
function greet(name?: string) {
  return `Hello, ${name || 'stranger'}`;
}

// Optional property in an interface
interface User {
  name: string;
  age?: number; // Same as `number | undefined` }
// Nullish Coalescing and Optional Chaining

    // Nullish coalescing (??) - only uses default if value is null or undefined
const value = input ?? 'default';

// Optional chaining (?.) - safely access nested properties
const street = user?.address?.street;
</code></pre>

<hr>
<h1>Arrays</h1>
<div class="explain"><p>readonly anahtar sözcüğü dizilerin değiştirilmesini önleyebilir.</p>
<p>TypeScript, bir Arrayın elamanlarından türü çıkarımlayabilir.</p></div>
    <pre><code>
        const names: readonly string[] = ["Dylan"];
names.push("Jack"); // Error: Property 'push' does not exist on type 'readonly string[]'.
// try removing the readonly modifier and see if it works?

        const numbers = [1, 2, 3]; // inferred to type number[]
numbers.push(4); // no error
// comment line below out to see the successful assignment
numbers.push("2"); // Error: Argument of type 'string' is not assignable to parameter of type 'number'.
let head: number = numbers[0]; // no error
        //alttaki kod hata verecek.
    numbers.push("2"); // Error: Argument of type 'string' is not assignable to parameter of type 'number'.


        console.log(numbers);
    </code></pre>
<output>
    NOTT: beklediğim gibi hata vermedi. Aksine oldu.
    [ 1, 2, 3, 4, '2' ]
</output>
<hr>
<h1>Tuple/Typed Arrays</h1>
<div class="explain"><p>Bir tuple, önceden tanımlanmış bir uzunluğa ve her indeks için türlere sahip türlendirilmiş bir dizidir. sıralama önemlidir.</p>
<p>Tuple'lar harikadır çünkü dizideki her bir elemanın bilinen bir değer türünde olmasına izin verirler.
</p></div>

<pre><code>
    // define our tuple
let ourTuple: [number, boolean, string];

    // initialize correctly
    ourTuple = [5, false, 'Coding'];
    //mesela ourTuple'ın ilk 3 (0 1 2) elemanının tipi belirlenmiş,
    //geri kalanına ne insert edersen et. kabul edecek ama tanımlanmış yerlere uygun tip gelmeli. Yoksa error verir.
</code></pre>

<pre><code>
    const car: { type: string, mileage: number } = {
    // Error: Property 'mileage' is missing in type '{ type: string; }' but required in type '{ type: string; mileage: number; }'.
  type: "Toyota",
};
car.mileage = 2000;
</code></pre>

<h1>Index signature</h1>
<div class="explain">
    <p>tanımlanmış bir property listesi olmayan nesneler için kullanılabilir</p>
</div>
<pre><code>
    const nameAgeMap: {[index: string]: number} = {};
nameAgeMap.Jack = 2000;
nameAgeMap.Mark = "Fifty"; // Error: Type 'string' is not assignable to type 'number'.

    console.log(nameAgeMap);
</code></pre>

<output>
Yinede output veriyor...
    { Jack: 2000, Mark: 'Fifty' }
</output>
<hr>
<h1>Enum's</h1>
<div class="explain"> <p>Enum sabit bir değişkendir.</p>
<p>Enum tanımlandığında default olarak 0 dan başlatır, kendimiz tanımlarsak değişkenlik gösterebilir.</p>
<p>Daha çok string enumlar kullanılıyor.</p></div>
<pre><code>
    enum StatusCodes {
    NotFound = 404,
    Success = 200,
    Accepted = 202,
    BadRequest = 400
}
// logs 404
console.log(StatusCodes.NotFound);
// logs 200
console.log(StatusCodes.Success);


enum CardinalDirections {
    North = 'North',
    East = "East",
    South = "South",
    West = "West"
}
// logs "North"
console.log(CardinalDirections.North);
// logs "West"
console.log(CardinalDirections.West);
</code></pre>

<output>
    404
    200
    North
    West
</output>
<hr>
<h1>Type Aliases</h1>

<div class="explain"> <p>Type aliases'ı kendimizce tip oluşturmamıza olanak tanıyor.</p>
<p>temel tipler(string, numbers vs) veya daha komplex(obje array vs.) tipleri tanımlamak için kullanılabilir</p></div>

<pre><code>
    //kullanım :
//Type Aliases
type CarYear = number
type CarType = string
type CarModel = string
type Car3 = {
    year: CarYear,
    type: CarType,
    model: CarModel
}

const carYear: CarYear = 2001
const carType: CarType = "Toyota"
const carModel: CarModel = "Corolla"
const car3: Car3 = {
    year: carYear,
    type: carType,
    model: carModel
};
//örnek
type Animal = { name: string };
type Bear = Animal & { honey: boolean };
const bear: Bear = { name: "Winnie", honey: true };

type Status = "success" | "error";
let response: Status = "success";

console.log(response);
console.log(bear);
console.log(typeof bear + " <-bear|response->" + typeof response);
</code></pre>
<output>
    success
    { name: 'Winnie', honey: true }
    object <-bear|response->string
</output>
<hr>
<h1>Interfaces</h1>
<div class="explain"> <p>Arayüzler, tür takma adlarına benzer, ancak yalnızca nesne türlerine uygulanırlar</p></div>
<pre><code>
    interface Rectangle {
  height: number,
  width: number
  sides: number[]
};

const rectangle: Rectangle = {
  height: 20,
  width: 10,
  sides: [20, 10, 20, 10]
};

console.log(rectangle);

console.log(typeof rectangle)
</code></pre>

<output>{ height: 20, width: 10, sides: [ 20, 10, 20, 10 ] }
    object
</output>

<div class="explain"> <p>Interface merging example</p></div>
<pre><code>
interface Tool { name: string; }
interface Tool { year: number; }
const pen: Tool = { name: "Pen", year: 12 };
console.log(typeof pen);
console.log(pen)

</code></pre>

<output>
    object
    { name: 'Pen', year: 12 }
</output>

<h1>Type vs Interface: Key Differences</h1>
<div class="explain"><p>İkiside extend edilebiliyor, ayrıca Interfaces merge edilebiliyor.</p>
<p>Sadece type aliases intersection/unions kesişimlerini destekliyor.</p>
<p>Sınıflar ikisine de uygulanabiliyor.</p>
<p>Objeler için Interface, geriye kalan her şey için Type kullanmamız öneriliyor.</p>

<h2>İyi tavsiyeler</h2>
<p>obje ve public API lar tanımlarken Interface kullan</p>
<p>Union, intersection ve primitivler için Type kullan</p>
<p>Type ve Interface tanımlarını dökümente et.</p></div>
<hr>
<h1>Union Types</h1>
<div class="explain">
    <p>tanımlama yaparken "|" kullanmak, mantıktaki OR kullanımına benzer.</p></div>

<pre><code>
function printStatusCode(code: string | number) {
  console.log(`My status code is ${code}.`)
}
printStatusCode(404);
printStatusCode('404');
</code></pre>

<output>
    My status code is 404.
    My status code is 404.
</output>

<div class="explain">
    <p>Tür hatalarından kaçınmak için, birleşim türlerinin ne olduğunu bilmek gerekir.</p>
</div>

<pre><code>
    function printStatusCode(code: string | number) {
  console.log(`My status code is ${code.toUpperCase()}.`) // error: Property 'toUpperCase' does not exist on type 'string | number'. Property 'toUpperCase' does not exist on type 'number'
}
</code></pre>

<output>

    C:\Users\ycanf\Desktop\web-learn\html\typescript\types.ts:200
    console.log(`My status code is ${code.toUpperCase()}.`) // error: Property 'toUpperCase' does not exist on type 'string | number'. Property 'toUpperCase' does not exist on type 'number'
    ^


    TypeError: code.toUpperCase is not a function
    at printStatusCode (C:\Users\ycanf\Desktop\web-learn\html\typescript\types.ts:200:43)
    at CardinalDirections (C:\Users\ycanf\Desktop\web-learn\html\typescript\types.ts:196:1)
    at Object.anonymous (C:\Users\ycanf\Desktop\web-learn\html\typescript\types.ts:199:10)
    at Module._compile (node:internal/modules/cjs/loader:1554:14)
    at Object.transformer (C:\Program Files\JetBrains\WebStorm 2025.2.4\plugins\nodeJS\js\ts-file-loader\node_modules\tsx\dist\register-DfubRCxM.cjs:2:823)
    at Module.load (node:internal/modules/cjs/loader:1289:32)
    at Function._load (node:internal/modules/cjs/loader:1108:12)
    at TracingChannel.traceSync (node:diagnostics_channel:322:14)
    at wrapModuleLoad (node:internal/modules/cjs/loader:220:24)
    at cjsLoader (node:internal/modules/esm/translators:262:5)

</output>
<hr>
<h1>Functions</h1>
<div class="explain">
    <p>Typescript'te fonskyionların parametreleri ve döndüreceği değerlerin tiplerini belirlemek için özel bir syntax vardır.</p>
    <p>Type Alias ile de fonkisyon yazılabiliyor. Bunu Burak abiye sor</p>
</div>

<pre><code>
    //return değerinin type belirlenmesi :
    function getTime(): number {
  return new Date().getTime();
}
    function printHello(): void {
  console.log('Hello!');
}
    // parametrelerin tipinin belirlenmesi
    function multiply(a: number, b: number) {
  return a * b;
}
    //Opsiyonel paramtereler '?' ile gösterilir.
    // the `?` operator here marks parameter `c` as optional
function add(a: number, b: number, c?: number) {
  return a + b + (c || 0);
}
    //Deafult parametreler
    function pow(value: number, exponent: number = 10) {
  return value ** exponent;
}
    //Named Parameters
function divide({ dividend, divisor }: { dividend: number, divisor: number }) {
  return dividend / divisor;
}

    // Rest Parameters
function add(a: number, b: number, ...rest: number[]) {
  return a + b + rest.reduce((p, c) => p + c, 0);
}

    //Type alias ile fonksiyon :
    type Negate = (value: number) => number;

// in this function, the parameter `value` automatically gets assigned the type `number` from the type `Negate`
const negateFunction: Negate = (value) => value * -1;
</code></pre>

<output></output>

<hr>
<h1>Casting</h1>
<div class="explain"><p>Değişkenlerin tiplerini override etmemiz gereken durumlar olabiliyor. Hazır kullandığımız kütüphanelerden gelen tipleri bazen override etmemiz gerekebiliyor..</p>
    <p>"Casting is the process of overriding a type."</p>
    <p>casting aslında verinin tipini değiştirmiyor, tekrar tanımlamıyor. Aşşağıda örneği var.</p>
    <p>Typecheck yapılmaya devam edilir aşşağıdaki örnekte, error throw ediyor, TypeScript, bir dizeyi sayıya dönüştürmenin, veriyi dönüştürmeden bir anlamı olmadığını bilir</p>
    <p> <> kullanmak as kullanmak ile aynıdır. Ancak TSX ile çalışırken işe yaramaz. </p>
    <p>Casting yapmaya zorlamak için ilk önce unknown daha sonrada istenilen tipe cast edilme şekilnde gerçekleştirilir. bu şekilde Type error'lar override edilebilir.</p>
</div>

<pre><code>
    let x: unknown = 4;
console.log((x as string).length); // prints undefined since numbers don't have a length
// casting aslında verinin tipini değiştirmiyor, tekrar tanımlamıyor mesela bu örnekte çıktı number olarak gösteriliyor.
console.log(typeof (x as string));
    --  Error throw edecek
    //Typescript cast kullanılırken dahi, typecheck yapmaya devam eder mesela aşşağıdaki error throw ediyor, TypeScript, bir dizeyi sayıya dönüştürmenin, veriyi dönüştürmeden bir anlamı olmadığını bilir:
console.log((4 as string).length);

// <> kullanmak as kullanmak ile aynıdır. ikiside Casting yapar.

    //Force Casting
    console.log(((x as unknown) as number).length);

    //Force Casting type errorları atlatmak için kullanılabilir.
console.log(((x as unknown) as number).length);
</code></pre>

<output>
    undefined
    number
    undefined
    4
    undefined
</output>

<hr>
<h1>Class</h1>
<div class="explain">
    <p>Typescript, javascript classlarına tip ve modifier (public private protected) ekler.</p>
    <p>public - class üyelerine her yerden erişim</p>
    <p>private - sadece class içinde erişim</p>
    <p>protected - sadece class üyesinin kendisinden ve onu miras alan sınıflardan. </p>
    <p>Örneği incele.</p>
    <p>TypeScript, parametreye bir görünürlük değiştiricisi ekleyerek sınıf üyelerini oluşturucuda tanımlamanın kullanışlı bir yolunu sağlar.</p>
    <p>Arraylerde ki gibi readonly ile sadece okuma modunda tanımlamalar yapılabilr.</p>
</div>

<pre><code>
class Telefon {
marka: string;
}
const telefon = new Telefon();
telefon.marka = 'Nokia';

console.log(telefon);

//Visiblity
class Araba {
private name: string;

public constructor(name: string) {
this.name = name;
}

public getName(): string {
return this.name;
}
}

const araba = new Araba("toyota");
console.log(araba.getName());
// constructor içindeki visiblity özelliğinin kullanımı :
    class Laptop {
    // name is a private member variable
    public constructor(private name: string) {}

    public getName(): string {
        return this.name;
    }
}

const laptop = new Laptop("Lenova");
console.log(laptop.getName());

    //Readonly
class Person {
    private readonly name: string;

    public constructor(name: string) {
        // name cannot be changed after this initial definition, which has to be either at its declaration or in the constructor.
        this.name = name;
    }

    public getName(): string {
        return this.name;
    }
}

const person = new Person("Jane");
console.log(person.getName());
</code></pre>


<div class="explain">
    <p></p>
</div>
<pre>
    <code>
        //Inheritance
        interface Shape {
  getArea: () => number;
}

class Rectangle implements Shape {
  public constructor(protected readonly width: number, protected readonly height: number) {}

  public getArea(): number {
    return this.width * this.height;
  }
}

    </code>
</pre>

<output>
    Telefon { marka: 'Nokia' }
    toyota
    Lenova
</output>

<hr>

<h1>Basic Generics</h1>
<div class="explain">
    <p>Generics (jenerikler) type variables oluşturmaya olanak sağlar. Type variables (tür değişkenleri) class, fonksyion ve type aliases oluştururken kullanılan type'ın açıkça tanımlanmasına gerek olmayan durumlarda kullanılır.</p>
    <p>Jenerikler, tekrar tekrar kullanılabilecek kodların yazımını kolaylaştırır.</p>
    <p>Jenerik ile yazılmış fonksiyonlar, daha genellenebilir, girdi çıktı tipleri isabetli olur.</p>
    <p>TypeScript ayrıca fonksiyon parametrelerinden genel parametrenin türünü de çıkarabilir.</p>
    <p>Generics sınıflar oluşturmak için Map gibi jenerikler kullanılabilir.</p>
    <p>Type Aliases jenerikler, daha kullanışlı yeniden kullanılabilir türler oluşturulmasına olanak tanır.</p>
    <p>Jenerikler için default değer atanabilir.</p>
    <p>Jeneriklere kısıtlamalar eklenebilir. Kısıtlamalar, jenerik tip kullanıldığında daha spesifik bir tipe güvenmeyi mümkün kılar.</p>
</div>

<pre><code>
//Generic function
function createPair &ltS, T&gt (v1: S, v2: T): [S, T] {
    return [v1, v2];
}

console.log(createPair &ltstring, number&gt('hello', 42)); // ['hello', 42]


</code></pre>

<pre><code>
    //Classes with generics
    class NamedValue &ltT&gt {
  private _value: T | undefined;

  constructor(private name: string) {}

  public setValue(value: T) {
    this._value = value;
  }

  public getValue(): T | undefined {
    return this._value;
  }

  public toString(): string {
    return `${this.name}: ${this._value}`;
  }
}

let value = new NamedValue &ltnumber&gt ('myNumber');
value.setValue(10);
console.log(value.toString()); // myNumber: 10
</code></pre>

<pre><code>
    //Type Aliases

    type Wrapped &ltT&gt = { value: T };

    const wrappedValue: Wrapped &ltnumber&gt = { value: 10 };

</code></pre>

<pre><code>
    //jeneriklere default değer atama
    class NamedValue &ltT = string> {
  private _value: T | undefined;

  constructor(private name: string) {}

  public setValue(value: T) {
    this._value = value;
  }

  public getValue(): T | undefined {
    return this._value;
  }

  public toString(): string {
    return `${this.name}: ${this._value}`;
  }
}

let value = new NamedValue('myval');
value.setValue('myValue');
console.log(value.toString()); // myNumber: myValue
</code></pre>

<pre>
    <code>
//Extends - constraints
function createLoggedPair &ltS extends string | number, T extends string | number&gt(v1: S, v2: T): [S, T] {
    console.log(`creating pair: v1='${v1}', v2='${v2}'`);
    return [v1, v2];
}
    </code>
</pre>

<output>
    [ 'hello', 42 ]

    myNumber: 10

    myVal: myValue
</output>



<hr>
<h1>TypeScript Utility Types</h1>
<div class="explain">
    <p>TypeScript, genellikle yardımcı türler olarak adlandırılan bazı yaygın tür manipülasyonlarına yardımcı olabilecek çok sayıda türle birlikte gelir.</p>
    <p>Bazı popüler utility; Partial, Required, Record, Omit, Pick, Exclude, ReturnType, Parameters, Readonly</p>
    <p>Partial, bir nesnedeki tüm özelliklerin isteğe bağlı olmasını sağlar.</p>
    <p>Required, bir nesnedeki tüm özelliklerin gerekli olmasını sağlar.</p>
    <p>Record, belirli bir anahtar türü ve değer türü ile bir nesne türünü tanımlamanın kısayoludur.</p>
    <p>Omit, bir nesne türünden anahtarları kaldırır.</p>
    <p>Pick, nesne türünden belirtilen anahtarlar dışındaki tüm anahtarları kaldırır.</p>
    <p>Exclude, ayırma işlemi gerçekleştirir.</p>
    <p>ReturnType, bir fonksiyon tipinin dönüş tipini çıkarır.</p>
    <p>Parametreler, bir fonksiyon tipinin parametre tiplerini bir dizi olarak çıkarır.</p>
    <p>Readonly, tüm özelliklerin salt okunur olduğu, yani bir değer atandıktan sonra değiştirilemeyeceği yeni bir tür oluşturmak için kullanılır</p>
    <p>!!örnekleri incele!!</p>
</div>

<pre><code>
// Type Utilty

// Partial

interface Point {
    x: number;
    y: number;
}

let pointPart : Partial &ltPoint&gt= {}; //'Partial allows x and y to be optional.'

pointPart.x =10;

console.log(pointPart);
</code></pre>

<pre><code>
    // required

interface Car {
    make: string;
    model: string;
    mileage?: number;
}

let myCar: Required &ltCar&gt = {
    make: 'Ford',
    model: 'Focus',
    mileage: 12000 // `Required` forces mileage to be defined
};
</code></pre>


<pre><code>

//Record

const nameAge: Record &ltstring, number&gt = {
    'Alice': 21,
    'Bob': 25
};
</code></pre>
interface Person {
name: string;
age: number;
location?: string;
}

const bob: Omit &ltPerson, 'age' | 'location'&gt = {
name: 'Bob'
// `Omit` has removed age and location from the type and they can't be defined here
};
<pre><code>
//Pick removes all but the specified keys from an object type.
interface Lion {
    called: string;
    age: number;
    location?: string;
}

const lion: Pick &ltLion, 'called'> = {
    called: 'lion'
    // `Pick` has only kept called, so age and location were removed from the type and they can't be defined here
};
</code></pre>

<pre><code>

//Exclude removes types from a union.

type Primitive = string | number | boolean
const val: Exclude &ltPrimitive, string> = true; // a string cannot be used here since Exclude removed it from the type.
</code></pre>

<pre><code>

//ReturnType extracts the return type of a function type.

type PointGenerator = () => { x: number; y: number; };
const point: ReturnType&ltPointGenerator&gt = {
    x: 10,
    y: 20
};
</code></pre>

<pre><code>
//Parameters extracts the parameter types of a function type as an array.
type PointPrinter = (p: { x: number; y: number; }) => void;
const point: Parameters&ltPointPrinter&gt[0] = {
    x: 10,
    y: 20
    };
</code></pre>

<hr>
<h1>keyof</h1>
<div class="explain">
    <p>keyof, TypeScript'te bir nesne türünden anahtar türünü çıkarmak için kullanılan bir anahtar sözcüktür.</p>
    <p>explicit anahtarlara sahip bir nesne türünde kullanıldığında, keyof bu anahtarlarla bir birleşim türü oluşturur.</p>
    <p>keyof ayrıca indeks türünü çıkarmak için indeks imzalarıyla birlikte de kullanılabilir.</p>
</div>

<pre><code>
interface Person {
  name: string;
  age: number;
}
// `keyof Person` here creates a union type of "name" and "age", other strings will not be allowed
function printPersonProperty(person: Person, property: keyof Person) {
  console.log(`Printing person property ${property}: "${person[property]}"`);
}
let person = {
  name: "Max",
  age: 27
};
printPersonProperty(person, "name"); // Printing person property name: "Max"
</code></pre>


<pre><code>
    //Keyof


interface Someone {
    called: string;
    age: number;
}
// `keyof Person` here creates a union type of "name" and "age", other strings will not be allowed
function printPersonProperty(person: Someone, property: keyof Someone) {
    console.log(`Printing person property ${property}: "${person[property]}"`);
}
let pers = {
    called: "Max",
    age: 27
};
printPersonProperty(pers, "called"); /
</code></pre>

<pre><code>
    type StringMap = { [key: string]: unknown };
// `keyof StringMap` resolves to `string` here
function createStringPair(property: keyof StringMap, value: string): StringMap {
  return { [property]: value };
}
</code></pre>

<output>
    Printing person property called: "Max"
</output>

<hr>
<h1> Async Progrraming</h1>
<div class="explain">
    <p>TypeScript, JavaScript'in asenkron yeteneklerini statik yazımla geliştirerek asenkron kodunuzu daha öngörülebilir ve sürdürülebilir hale getirir. Bu kılavuz, temel asenkron/await gelişmiş kalıplara kadar her şeyi kapsar.</p>
    <p>Promises : Promise&lt;T&gt; (T jenerik tip.) - Promise&lt;void&gt; değer dönmeyen - Promise&lt;never&gt; asla resolve olmayan promisler için.</p>
    <p>Promise.all ile paralel bir biçimde birden çok async operasyon işlemi yapılabilir.</p>
    <p>TypeScript'teki tüm asenkron fonksiyonlar bir Promise döndürür.</p>

</div>

<pre><code>
    //Basic promise example
    // Create a typed Promise that resolves to a string
const fetchGreeting = (): Promise &lt;string&gt; => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const success = Math.random() > 0.5;
      if (success) {
        resolve("Hello, TypeScript!");
      } else {
        reject(new Error("Failed to fetch greeting"));
      }
    }, 1000);
  });
};

// Using the Promise with proper type inference
fetchGreeting()
  .then((greeting) => {
    // TypeScript knows 'greeting' is a string
    console.log(greeting.toUpperCase());
  })
  .catch((error: Error) => {
    console.error("Error:", error.message);
  });
</code></pre>

<pre><code>
    //await/aysnc

    // Define types for our API response
interface User {
  id: number;
  name: string;
  email: string;
  role: 'admin' | 'user' | 'guest';
}

// Function that returns a Promise of User array
async function fetchUsers(): Promise &lt;User[]&gt; {
  console.log('Fetching users...');
  // Simulate API call
  await new Promise(resolve => setTimeout(resolve, 1000));
  return [
    { id: 1, name: 'Alice', email: 'alice@example.com', role: 'admin' },
    { id: 2, name: 'Bob', email: 'bob@example.com', role: 'user' }
  ];
}

// Async function to process users
async function processUsers() {
  try {
    // TypeScript knows users is User[]
    const users = await fetchUsers();
    console.log(`Fetched ${users.length} users`);

    // Type-safe property access
    const adminEmails = users
      .filter(user => user.role === 'admin')
      .map(user => user.email);

    console.log('Admin emails:', adminEmails);
    return users;
  } catch (error) {
    if (error instanceof Error) {
      console.error('Failed to process users:', error.message);
    } else {
      console.error('An unknown error occurred');
    }
    throw error; // Re-throw to let caller handle
  }
}

// Execute the async function
processUsers()
  .then(users => console.log('Processing complete'))
  .catch(err => console.error('Processing failed:', err));

</code></pre>

<output>
    No yard
    Fetching users...
    Fetched 2 users
    Admin emails: [ 'alice@example.com' ]
    Processing complete
</output>

<div class="explain"> <p>Paralel execution</p></div>
<pre><code>
// Different types of promises
const fetchUser = (id: number): Promise<{ id: number; name: string }> =>
  Promise.resolve({ id, name: `User ${id}` });

const fetchPosts = (userId: number): Promise &ltArray&lt{ id: number; title: string }>> =>
  Promise.resolve([     { id: 1, title: 'Post 1' },
    { id: 2, title: 'Post 2' }
  ]);

const fetchStats = (userId: number): Promise<{ views: number; likes: number }> =>
  Promise.resolve({ views: 100, likes: 25 });

// Run all in parallel
async function loadUserDashboard(userId: number) {
  try {
    const [user, posts, stats] = await Promise.all([
      fetchUser(userId),
      fetchPosts(userId),
      fetchStats(userId)
    ]);

    // TypeScript knows the types of user, posts, and stats
    console.log(`User: ${user.name}`);
    console.log(`Posts: ${posts.length}`);
    console.log(`Likes: ${stats.likes}`);

    return { user, posts, stats };
  } catch (error) {
    console.error('Failed to load dashboard:', error);
    throw error;
  }
}

// Execute with a user ID
loadUserDashboard(1);
</code></pre>


</body>
</html>