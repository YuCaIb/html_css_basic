<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <link rel="stylesheet" href="style/style.css">
</head>
<body>

<h1>Yükleme</h1>
<div class="explain">
    <p>"npm install --global typescript" komutu ile yükleniyor.</p>
    <p>"tsc -v" ile versiyon kontrolü. npm init -y ile iligli dizinde package.json oluşturuluyor.</p>
    <p>"npx tsc whatevernameis.ts" komutu ile ts dosyasını js dosyasına çeviriyoruz.</p>
</div>


<hr>

<h1>Hello World</h1>

<div class="explain">
    <p>TS dünyasına ilk kodum (buraya açıklamalar gelicek)</p>
</div>
)

<pre><code>
function selamDunya() {
  console.log("Merhaba Dünya!");
}
</code>
</pre>
<output>
    Merhaba Dünya
</output>
<hr>
<h1>5 Temel Tip</h1>
<div class="explain">
    <p> boolean, number, string, Bigint(2^53 - 1 sayısından büyük), Symbol</p>
</div>
<pre>
    <code>
        //Boolean
        let isactive: boolean = false;
        let hasError = true;  //Python gibi kendisi de çıkarım yapabiliyor.

        //number
        let decimal: number = 25;
        let hex: number = 0xf00d;
        let binary: number = 0b1010;
        let octal: number = 0o744;
        let float: number = 3.14;

        //String
        let name: string = "Yusuf Can"
        let surname: string = "İbişoğlu"

let sentence: string = "Hello my name is " + name + " " + surname + " and I'm " + decimal + " Years old.";

console.log(sentence)
    </code>
</pre>

<output>
    Hello my name is Yusuf Can İbişoğlu and I'm 25 Years old.
</output>

<div class="explain">
<p>Symbol unique tanımlayıcılar oluşturur. Unique özellik key ve constant oluşturmak için kullanışlıdır.</p>
</div>
<pre><code>
    const uniqueKey: symbol = Symbol('description');
const obj = {
    [uniqueKey]: 'This is a unique property'
};
console.log(obj[uniqueKey]); // "This is a unique property"
</code></pre>
<output>
    This is a unique property
</output>

<hr>
<h1>Inference - Çıkarım</h1>
<div class="explain"><p>//return tipini de belirleyebiliyoruz. Belirlemessek çıkarım (inferrence) yapıyor.</p></div>
<pre>
    <code>
        function ornek(name: string): string {
    return `Hello, ${name}!`;}
    </code>
</pre>

<pre><code>const user = {
    name: 'yusuf',
    surname: "ibisoglu",
    isadmin: false,
    age: 25
}

    console.log(user.name);
</code></pre>

<output>
    yusuf
    undefined
</output>
<hr>
<div class="explain"><p>/*
    TypeScript inference özelliği oldukça güçlü. Ancak tipi tanımlayamadığı durumlar olabiliyor.
    mesela intellisense aşşağıda data değişkenini any olarak atadı. yazzdırdığımda ise object
    </p></div>

<pre><code>
    const data = JSON.parse('{"name":"yusuf","surname":"ibisoglu","isadmin":true}');
    console.log(typeof data);
</code></pre>

<output>
    object
</output>
<h1>any</h1>
<div class="explain"><p>any js kodumuzu ts'ye migrate(taşırken) ederken kullanabiliriz.</p>
<p>dinamik content ile çalışırken, tip unkown ise kullanılabilir</p>
</div>
<pre><code>
    let v: any = true;
v = "string"; // no error as it can be "any" type
Math.round(v); // no error as it can be "any" type
console.log(v); // "string"
    //genelde any error dönmez
</code></pre>

<hr>
<h1>Unknown</h1>
<div class="explain">
    <p>unknown any'nin güvenli versiyonu, property'leri çapıramassın</p>
    <p>kullanmadan önce kontrol etmemiz gerekiyor (assert) çağıramayız ve construct edemeyiz.</p>
</div>
<pre><code>
    let w: unknown = 1;

w = "string";

w = {
    runANonExistentMethod: () => {
        console.log("I think");
    }
} as { runANonExistentMethod: () => void }

    console.log(w)
    if (typeof w === 'object' && w !== null) {
    (w as { runANonExistentMethod: Function }).runANonExistentMethod();
}
</code></pre>

<output>
    object
    { runANonExistentMethod: [Function: runANonExistentMethod] }
    I think
</output>


<hr>
<h1>Unkown ne zaman kullanılır.</h1>
<div class="explain"><p>// Dışardan veri aldığımızda (API vs) veri tiplerinden emin olmamız gerektiğinde.
</p>
<p>// java scriptten Type Scripte güvenli bir geçiş yaptığımızda (kodları js den ts e çevirirken.)
</p></div>
<pre><code>
    // Unkown ne zaman kullanılır
    function processValue(value: unknown) {
    if (typeof value === 'string') {
    // value is now treated as string
    console.log(value.toUpperCase());
    } else if (Array.isArray(value)) {
    // value is now treated as any[]
    console.log(value.length);
    }
    }
    let absc: number[] = [2, 3];
    processValue(absc)
</code></pre>

<output>
    2
</output>
<hr>
<h1>Never type</h1>
<div class="explain"><p>// Hiç bir zaman meydana gelmeyecek / gelmemesi gereken değerleri temsil eder.
</p>
<p>Basic never type (throws error when assigned)
</p></div>
<pre>
    <code> //never return eden fonksyion
        function throwError(message: string): never {
    throw new Error(message);
}
        --------
        type Shape = Circle | Square | Triangle;

function getArea(shape: Shape): number {
    switch (shape.kind) {
        case 'circle':
            return Math.PI * shape.radius ** 2;
        case 'square':
            return shape.sideLength ** 2;
        default:
            // TypeScript knows this should never happen
            const _exhaustiveCheck: never = shape;
            return _exhaustiveCheck;
    }
}
        //Basic never type (throws error when assigned)
        let x: never = true; // Error: Type 'boolean' is not assignable to type 'never'.
    </code>
</pre>
<hr>
<h1>Type: undefined & null</h1>
<div class="explain"><p>Typescriptte undefined ve null birer tiptir, string veya number gibi.</p>
<p>bu tipler varsayılan olarak, herhangi bir tipe dönüştürülebilir.</p></div>
<pre><code>
    let y: undefined = undefined;
    let z: null = null;
    // Opsiyonel parametre ve property özellikleri  :
    // Optional parameter (implicitly `string | undefined`)
function greet(name?: string) {
  return `Hello, ${name || 'stranger'}`;
}

// Optional property in an interface
interface User {
  name: string;
  age?: number; // Same as `number | undefined` }
// Nullish Coalescing and Optional Chaining

    // Nullish coalescing (??) - only uses default if value is null or undefined
const value = input ?? 'default';

// Optional chaining (?.) - safely access nested properties
const street = user?.address?.street;
</code></pre>

<hr>
<h1>Arrays</h1>
<div class="explain"><p>readonly anahtar sözcüğü dizilerin değiştirilmesini önleyebilir.</p>
<p>TypeScript, bir Arrayın elamanlarından türü çıkarımlayabilir.</p></div>
    <pre><code>
        const names: readonly string[] = ["Dylan"];
names.push("Jack"); // Error: Property 'push' does not exist on type 'readonly string[]'.
// try removing the readonly modifier and see if it works?

        const numbers = [1, 2, 3]; // inferred to type number[]
numbers.push(4); // no error
// comment line below out to see the successful assignment
numbers.push("2"); // Error: Argument of type 'string' is not assignable to parameter of type 'number'.
let head: number = numbers[0]; // no error
        //alttaki kod hata verecek.
    numbers.push("2"); // Error: Argument of type 'string' is not assignable to parameter of type 'number'.


        console.log(numbers);
    </code></pre>
<output>
    NOTT: beklediğim gibi hata vermedi. Aksine oldu.
    [ 1, 2, 3, 4, '2' ]
</output>
<hr>
<h1>Tuple/Typed Arrays</h1>
<div class="explain"><p>Bir tuple, önceden tanımlanmış bir uzunluğa ve her indeks için türlere sahip türlendirilmiş bir dizidir. sıralama önemlidir.</p>
<p>Tuple'lar harikadır çünkü dizideki her bir elemanın bilinen bir değer türünde olmasına izin verirler.
</p></div>

<pre><code>
    // define our tuple
let ourTuple: [number, boolean, string];

    // initialize correctly
    ourTuple = [5, false, 'Coding'];
    //mesela ourTuple'ın ilk 3 (0 1 2) elemanının tipi belirlenmiş,
    //geri kalanına ne insert edersen et. kabul edecek ama tanımlanmış yerlere uygun tip gelmeli. Yoksa error verir.
</code></pre>

<pre><code>
    const car: { type: string, mileage: number } = { // Error: Property 'mileage' is missing in type '{ type: string; }' but required in type '{ type: string; mileage: number; }'.
  type: "Toyota",
};
car.mileage = 2000;
</code></pre>

<h1>Index signature</h1>
<div class="explain">
    <p>tanımlanmış bir property listesi olmayan nesneler için kullanılabilir</p>
</div>
<pre><code>
    const nameAgeMap: {[index: string]: number} = {};
nameAgeMap.Jack = 2000;
nameAgeMap.Mark = "Fifty"; // Error: Type 'string' is not assignable to type 'number'.

    console.log(nameAgeMap);
</code></pre>

<output>
Yinede output veriyor...
    { Jack: 2000, Mark: 'Fifty' }
</output>
<hr>
<h1>Enum's</h1>
<div class="explain"> <p>Enum sabit bir değişkendir.</p>
<p>Enum tanımlandığında default olarak 0 dan başlatır, kendimiz tanımlarsak değişkenlik gösterebilir.</p>
<p>Daha çok string enumlar kullanılıyor.</p></div>
<pre><code>
    enum StatusCodes {
    NotFound = 404,
    Success = 200,
    Accepted = 202,
    BadRequest = 400
}
// logs 404
console.log(StatusCodes.NotFound);
// logs 200
console.log(StatusCodes.Success);


enum CardinalDirections {
    North = 'North',
    East = "East",
    South = "South",
    West = "West"
}
// logs "North"
console.log(CardinalDirections.North);
// logs "West"
console.log(CardinalDirections.West);
</code></pre>

<output>
    404
    200
    North
    West
</output>
<hr>
<h1>Type Aliases</h1>

<div class="explain"> <p>Type aliases'ı kendimizce tip oluşturmamıza olanak tanıyor.</p>
<p>temel tipler(string, numbers vs) veya daha komplex(obje array vs.) tipleri tanımlamak için kullanılabilir</p></div>

<pre><code>
    //kullanım :
//Type Aliases
type CarYear = number
type CarType = string
type CarModel = string
type Car3 = {
    year: CarYear,
    type: CarType,
    model: CarModel
}

const carYear: CarYear = 2001
const carType: CarType = "Toyota"
const carModel: CarModel = "Corolla"
const car3: Car3 = {
    year: carYear,
    type: carType,
    model: carModel
};
//örnek
type Animal = { name: string };
type Bear = Animal & { honey: boolean };
const bear: Bear = { name: "Winnie", honey: true };

type Status = "success" | "error";
let response: Status = "success";

console.log(response);
console.log(bear);
console.log(typeof bear + " <-bear|response->" + typeof response);
</code></pre>
<output>
    success
    { name: 'Winnie', honey: true }
    object <-bear|response->string
</output>
<hr>
<h1>Interfaces</h1>
<div class="explain"> <p></p></div>
<pre><code>
    interface Rectangle {
  height: number,
  width: number
  sides: number[]
};

const rectangle: Rectangle = {
  height: 20,
  width: 10,
  sides: [20, 10, 20, 10]
};

console.log(rectangle);

console.log(typeof rectangle)
</code></pre>

<output>{ height: 20, width: 10, sides: [ 20, 10, 20, 10 ] }
    object
</output>

<div class="explain"> <p>Interface merging example</p></div>
<pre><code>
interface Tool { name: string; }
interface Tool { year: number; }
const pen: Tool = { name: "Pen", year: 12 };
console.log(typeof pen);
console.log(pen)

</code></pre>

<output>
    object
    { name: 'Pen', year: 12 }
</output>

<h1>Type vs Interface: Key Differences</h1>
<div class="explain"><p>İkiside extend edilebiliyor, ayrıca Interfaces merge edilebiliyor.</p>
<p>Sadece type aliases intersection/unions kesişimlerini destekliyor.</p>
<p>Sınıflar ikisine de uygulanabiliyor.</p>
<p>Objeler için Interface, geriye kalan her şey için Type kullanmamız öneriliyor.</p>

<h2>İyi tavsiyeler</h2>
<p>obje ve public API lar tanımlarken Interface kullan</p>
<p>Union, intersection ve primitivler için Type kullan</p>
<p>Type ve Interface tanımlarını dökümente et.</p></div>
<hr>
<h1>Union Types</h1>
<div class="explain">
    <p>tanımlama yaparken "|" kullanmak, mantıktaki OR kullanımına benzer.</p></div>

<pre><code>
function printStatusCode(code: string | number) {
  console.log(`My status code is ${code}.`)
}
printStatusCode(404);
printStatusCode('404');
</code></pre>

<output>
    My status code is 404.
    My status code is 404.
</output>

<div class="explain">
    <p>Tür hatalarından kaçınmak için, birleşim türlerinin ne olduğunu bilmek gerekir.</p>
</div>

<pre><code>
    function printStatusCode(code: string | number) {
  console.log(`My status code is ${code.toUpperCase()}.`) // error: Property 'toUpperCase' does not exist on type 'string | number'. Property 'toUpperCase' does not exist on type 'number'
}
</code></pre>

<output>

    C:\Users\ycanf\Desktop\web-learn\html\typescript\types.ts:200
    console.log(`My status code is ${code.toUpperCase()}.`) // error: Property 'toUpperCase' does not exist on type 'string | number'. Property 'toUpperCase' does not exist on type 'number'
    ^


    TypeError: code.toUpperCase is not a function
    at printStatusCode (C:\Users\ycanf\Desktop\web-learn\html\typescript\types.ts:200:43)
    at CardinalDirections (C:\Users\ycanf\Desktop\web-learn\html\typescript\types.ts:196:1)
    at Object.anonymous (C:\Users\ycanf\Desktop\web-learn\html\typescript\types.ts:199:10)
    at Module._compile (node:internal/modules/cjs/loader:1554:14)
    at Object.transformer (C:\Program Files\JetBrains\WebStorm 2025.2.4\plugins\nodeJS\js\ts-file-loader\node_modules\tsx\dist\register-DfubRCxM.cjs:2:823)
    at Module.load (node:internal/modules/cjs/loader:1289:32)
    at Function._load (node:internal/modules/cjs/loader:1108:12)
    at TracingChannel.traceSync (node:diagnostics_channel:322:14)
    at wrapModuleLoad (node:internal/modules/cjs/loader:220:24)
    at cjsLoader (node:internal/modules/esm/translators:262:5)

</output>
<hr>
<h1>Functions</h1>
<div class="explain">
    <p>Typescript'te fonskyionların parametreleri ve döndüreceği değerlerin tiplerini belirlemek için özel bir syntax vardır.</p>
    <p>Type Alias ile de fonkisyon yazılabiliyor. Bunu Burak abiye sor</p>
</div>

<pre><code>
    //return değerinin type belirlenmesi :
    function getTime(): number {
  return new Date().getTime();
}
    function printHello(): void {
  console.log('Hello!');
}
    // parametrelerin tipinin belirlenmesi
    function multiply(a: number, b: number) {
  return a * b;
}
    //Opsiyonel paramtereler '?' ile gösterilir.
    // the `?` operator here marks parameter `c` as optional
function add(a: number, b: number, c?: number) {
  return a + b + (c || 0);
}
    //Deafult parametreler
    function pow(value: number, exponent: number = 10) {
  return value ** exponent;
}
    //Named Parameters
function divide({ dividend, divisor }: { dividend: number, divisor: number }) {
  return dividend / divisor;
}

    // Rest Parameters
function add(a: number, b: number, ...rest: number[]) {
  return a + b + rest.reduce((p, c) => p + c, 0);
}

    //Type alias ile fonksiyon :
    type Negate = (value: number) => number;

// in this function, the parameter `value` automatically gets assigned the type `number` from the type `Negate`
const negateFunction: Negate = (value) => value * -1;
</code></pre>

<output></output>

<hr>
<h1>Casting</h1>
<div class="explain"><p>Değişkenlerin tiplerini override etmemiz gereken durumlar olabiliyor. Hazır kullandığımız kütüphanelerden gelen tipleri bazen override etmemiz gerekebiliyor..</p>
    <p>"Casting is the process of overriding a type."</p>
    <p>casting aslında verinin tipini değiştirmiyor, tekrar tanımlamıyor. Aşşağıda örneği var.</p>
    <p>Typecheck yapılmaya devam edilir aşşağıdaki örnekte, error throw ediyor, TypeScript, bir dizeyi sayıya dönüştürmenin, veriyi dönüştürmeden bir anlamı olmadığını bilir</p>
    <p> <> kullanmak as kullanmak ile aynıdır. Ancak TSX ile çalışırken işe yaramaz. </p>
    <p>Casting yapmaya zorlamak için ilk önce unknown daha sonrada istenilen tipe cast edilme şekilnde gerçekleştirilir. bu şekilde Type error'lar override edilebilir.</p>
</div>

<pre><code>
    let x: unknown = 4;
console.log((x as string).length); // prints undefined since numbers don't have a length
// casting aslında verinin tipini değiştirmiyor, tekrar tanımlamıyor mesela bu örnekte çıktı number olarak gösteriliyor.
console.log(typeof (x as string));
    --  Error throw edecek
    //Typescript cast kullanılırken dahi, typecheck yapmaya devam eder mesela aşşağıdaki error throw ediyor, TypeScript, bir dizeyi sayıya dönüştürmenin, veriyi dönüştürmeden bir anlamı olmadığını bilir:
console.log((4 as string).length);

// <> kullanmak as kullanmak ile aynıdır. ikiside Casting yapar.

    //Force Casting
    console.log(((x as unknown) as number).length);

    //Force Casting type errorları atlatmak için kullanılabilir.
console.log(((x as unknown) as number).length);
</code></pre>

<output>
    undefined
    number
    undefined
    4
    undefined
</output>

<hr>
<h1>Class</h1>
<div class="explain">
    <p>Typescript, javascript classlarına tip ve modifier (public private protected) ekler.</p>
    <p>public - class üyelerine her yerden erişim</p>
    <p>private - sadece class içinde erişim</p>
    <p>protected - sadece class üyesinin kendisinden ve onu miras alan sınıflardan. </p>
    <p>Örneği incele.</p>
    <p>TypeScript, parametreye bir görünürlük değiştiricisi ekleyerek sınıf üyelerini oluşturucuda tanımlamanın kullanışlı bir yolunu sağlar.</p>
    <p>Arraylerde ki gibi readonly ile sadece okuma modunda tanımlamalar yapılabilr.</p>
</div>

<pre><code>
class Telefon {
marka: string;
}
const telefon = new Telefon();
telefon.marka = 'Nokia';

console.log(telefon);

//Visiblity
class Araba {
private name: string;

public constructor(name: string) {
this.name = name;
}

public getName(): string {
return this.name;
}
}

const araba = new Araba("toyota");
console.log(araba.getName());
// constructor içindeki visiblity özelliğinin kullanımı :
    class Laptop {
    // name is a private member variable
    public constructor(private name: string) {}

    public getName(): string {
        return this.name;
    }
}

const laptop = new Laptop("Lenova");
console.log(laptop.getName());

    //Readonly
class Person {
    private readonly name: string;

    public constructor(name: string) {
        // name cannot be changed after this initial definition, which has to be either at its declaration or in the constructor.
        this.name = name;
    }

    public getName(): string {
        return this.name;
    }
}

const person = new Person("Jane");
console.log(person.getName());
</code></pre>


<div class="explain">
    <p></p>
</div>
<pre>
    <code>
        //Inheritance
        interface Shape {
  getArea: () => number;
}

class Rectangle implements Shape {
  public constructor(protected readonly width: number, protected readonly height: number) {}

  public getArea(): number {
    return this.width * this.height;
  }
}

    </code>
</pre>

<output>
    Telefon { marka: 'Nokia' }
    toyota
    Lenova
</output>

<hr>

<h1></h1>
<div class="explain"><p></p></div>

<pre><code>

</code></pre>

<output>

</output>

<hr>
</body>
</html>